plugins {
    id 'eclipse'
    id 'java-library'
    alias libs.plugins.gradleutils
    alias libs.plugins.licenser
    alias libs.plugins.modules
    id 'test-report-aggregation'
}

java {
    toolchain.languageVersion = JavaLanguageVersion.of(21)
}

license {
    header = rootProject.file('LICENSE-header.txt')
    newLine = false
}

dependencies {
    testImplementation rootProject
    testImplementation projects.eventbusTestJar
    testImplementation projects.eventbusValidator
    testImplementation libs.junit.api
    testImplementation libs.jspecify.annotations
    testImplementation libs.compile.testing
    testImplementation libs.auto.value
    testImplementation libs.jetbrains.annotations
    testRuntimeOnly libs.bundles.junit.runtime
}

extraJavaModuleInfo {
    failOnMissingModuleInfo = false
    automaticModule(libs.compile.testing, "compile.testing")
}

tasks.named('test', Test) {
    useJUnitPlatform()
    systemProperties = ['eventbus.api.strictBusCreationChecks': true]
}

tasks.register('testAll', AggregateTest) {
    input = file('build/test-results/')
    output = rootProject.file('test_results.html')
}

((Map<String, List<Integer>>) ext.VALID_VMS).forEach { javaVendor, javaVersions ->
    for (Integer javaVersion in javaVersions) {
        var output = file("build/test-results/${javaVendor}-${javaVersion}/")
        output.mkdirs()
        var task = tasks.register("test${javaVendor}${javaVersion}", Test) {
            useJUnitPlatform()
            classpath = configurations.runtimeClasspath
            testClassesDirs = sourceSets.main.output.classesDirs
            javaLauncher = javaToolchains.launcherFor {
                vendor = JvmVendorSpec."${javaVendor.toUpperCase(Locale.ROOT)}" as JvmVendorSpec
                languageVersion = JavaLanguageVersion.of(javaVersion)
                implementation = JvmImplementation.VENDOR_SPECIFIC
            }
            reports.html.outputLocation.fileValue file("build/test-reports/${javaVendor}-${javaVersion}/")
            reports.junitXml.outputLocation.fileValue output
        }
        tasks.named('testAll') {
            inputs.dir(output)
            dependsOn task
            mustRunAfter task
        }
    }
}

// Hack eclipse into knowing that the gradle deps are modules
eclipse.classpath {
    containers 'org.eclipse.buildship.core.gradleclasspathcontainer'
    file.whenMerged { entries.findAll { it.kind == 'lib' || it.path == 'org.eclipse.buildship.core.gradleclasspathcontainer' }.each { it.entryAttributes['module'] = 'true' } }
}
